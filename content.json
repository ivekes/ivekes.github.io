[{"title":"hexo","date":"2019-07-22T15:36:51.000Z","path":"2019/07/22/hexo/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: [Deployment](","tags":[{"name":"hexo","slug":"hexo","permalink":"https://ivekes.github.io/tags/hexo/"}]},{"title":"shell编程点滴","date":"2019-07-22T15:34:49.000Z","path":"2019/07/22/shell编程点滴/","text":"变量命名变量 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头 中间不能有空格，可以使用下划线（_） 不能使用标点符号 不能使用 bash 里的关键字（可用 help 命令查看保留关键字） 除了显式地直接赋值，还可以用语句给变量赋值，如: 123for file in `ls /etc`或for file in $(ls /etc) 使用变量使用一个定义过的变量，只要在变量名前面加美元符号即可，如： 123your_name=\"qinjx\"echo $your_nameecho $&#123;your_name&#125; 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况： 123for skill in Ada Coffe Action Java; do echo \"I am good at $&#123;skill&#125;Script\"done 已定义的变量，可以被重新定义，如： 1234your_name=\"tom\"echo $your_nameyour_name=\"alibaba\"echo $your_name 这样写是合法的，但注意，第二次赋值的时候不能写$your_name=”alibaba”，使用变量的时候才加美元符（$） 只读变量使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变 下面的例子尝试更改只读变量，结果报错： 1234#!/bin/bashmyUrl=\"http://www.google.com\"readonly myUrlmyUrl=\"http://www.runoob.com\" 运行脚本，结果如下： 1/bin/sh: NAME: This variable is read only. 删除变量使用 unset 命令可以删除变量。语法： 1unset variable_name 变量被删除后不能再次使用。unset 命令不能删除只读变量 实例 1234#!/bin/shmyUrl=\"http://www.runoob.com\"unset myUrlecho $myUrl 变量类型运行shell时，会同时存在三种变量 局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量 环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量 shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 字符串字符串赋值字符串可以用双引号，也可以用单引号，也可以不用引号 12345#!/bin/shjava=\"java课程\"shell='shell课程'python=python课程echo $java $shell $python 输出结果为： 1java课程 shell课程 python课程 单引号/双引号,反引号字符串的区别: 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用 双引号里可以有变量 双引号里可以出现转义字符 字符串拼接123456789your_name=\"shell\"# 使用双引号拼接greeting=\"hello, \"$your_name\" !\"greeting_1=\"hello, $&#123;your_name&#125; !\"echo $greeting $greeting_1# 使用单引号拼接greeting_2='hello, '$your_name' !'greeting_3='hello, $&#123;your_name&#125; !'echo $greeting_2 $greeting_3 输出结果为： 12hello, shell ! hello, shell !hello, shell ! hello, $&#123;your_name&#125; ! 字符串长度12string=\"abcd\"echo $&#123;#string&#125; #输出 4 提取子字符串以下实例从字符串第 2 个字符开始截取 4 个字符： 12string=\"java shell python\"echo $&#123;string:1:4&#125; # 输出 ava 查找子字符串12string=\"java shell python\"echo `expr index \"$string\" va` # 输出 2 数组数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0 定义数组在 Shell 中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为： 1数组名=(值1 值2 ... 值n) 例如： 1array_name=(value0 value1 value2 value3) 或者 123456array_name=(value0value1value2value3) 还可以单独定义数组的各个分量 123array_name[0]=value0array_name[1]=value1array_name[n]=valuen 可以不使用连续的下标，而且下标的范围没有限制 读取数组读取数组元素值的一般格式是： 1$&#123;数组名[下标]&#125; 例如： 1valuen=$&#123;array_name[n]&#125; 使用 @/* 符号可以获取数组中的所有元素，例如： 12echo $&#123;array_name[@]&#125;echo $&#123;array_name[*]&#125; 获取数组的长度获取数组长度的方法与获取字符串长度的方法相同，例如： 123456# 取得数组元素的个数length=$&#123;#array_name[@]&#125; #2# 或者length=$&#123;#array_name[*]&#125; #2# 取得数组单个元素的长度lengthn=$&#123;#array_name[n]&#125; #6 函数shell中函数的定义格式如下： 12345[ function ] funname [()]&#123; action; [return int;]&#125; 说明： 1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。 2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255 下面的例子定义了一个函数并进行调用： 12345678910111213#!/bin/bashdemoFun()&#123; echo \"这是我的第一个 shell 函数!\"&#125;echo \"-----函数开始执行-----\"demoFunecho \"-----函数执行完毕-----\"输出结果：-----函数开始执行-----这是我的第一个 shell 函数!-----函数执行完毕----- 下面定义一个带有return语句的函数： 12345678910111213141516171819202122#!/bin/bashfunWithReturn()&#123; echo \"这个函数会对输入的两个数字进行相加运算...\" echo \"输入第一个数字: \" read aNum echo \"输入第二个数字: \" read anotherNum echo \"两个数字分别为 $aNum 和 $anotherNum !\" return $(($aNum+$anotherNum))&#125;funWithReturnecho \"输入的两个数字之和为 $? !\"输出类似下面：这个函数会对输入的两个数字进行相加运算...输入第一个数字: 1输入第二个数字: 2两个数字分别为 1 和 2 !输入的两个数字之和为 3 ! 函数返回值在调用该函数后通过 $? 来获得。 注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。 函数参数在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数… 带参数的函数示例： 12345678910111213141516171819202122#!/bin/bashfunWithParam()&#123; echo \"第一个参数为 $1 !\" echo \"第二个参数为 $2 !\" echo \"第十个参数为 $10 !\" echo \"第十个参数为 $&#123;10&#125; !\" echo \"第十一个参数为 $&#123;11&#125; !\" echo \"参数总数有 $# 个!\" echo \"作为一个字符串输出所有参数 $* !\"&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73输出结果：第一个参数为 1 !第二个参数为 2 !第十个参数为 10 !第十个参数为 34 !第十一个参数为 73 !参数总数有 11 个!作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 ! 注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。 另外，还有几个特殊字符用来处理参数： 参数处理 说明 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。 $- 显示Shell使用的当前选项，与set命令功能相同。 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 注释以 # 开头的行就是注释，会被解释器忽略 单行注释通过每一行加一个 # 号设置单行注释 1# 这是一个注释 多行注释多行注释还可以使用以下格式 123456789101112131415161718192021:&lt;&lt;EOF注释内容...注释内容...注释内容...EOF或者:&lt;&lt;'注释内容...注释内容...注释内容...'或者:&lt;&lt;!注释内容...注释内容...注释内容...! 运算符expr 是一款表达式计算工具，使用它能完成表达式的求值操作 基本运算符 运算符 说明 举例 + 加法 expr $a + $b 结果为 30。 - 减法 expr $a - $b 结果为 -10。 * 乘法 expr $a \\* $b 结果为 200。 / 除法 expr $b / $a 结果为 2。 % 取余 expr $b % $a 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。 != 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。 注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ] 实例 12345678910111213141516171819202122232425262728293031323334353637&gt; #!/bin/bash&gt; &gt; a=10&gt; b=20&gt; &gt; val=`expr $a + $b`&gt; echo \"a + b : $val\"&gt; &gt; val=`expr $a - $b`&gt; echo \"a - b : $val\"&gt; &gt; val=`expr $a \\* $b`&gt; echo \"a * b : $val\"&gt; &gt; val=`expr $b / $a`&gt; echo \"b / a : $val\"&gt; &gt; val=`expr $b % $a`&gt; echo \"b % a : $val\"&gt; &gt; if [ $a == $b ]&gt; then&gt; echo \"a 等于 b\"&gt; fi&gt; if [ $a != $b ]&gt; then&gt; echo \"a 不等于 b\"&gt; fi&gt; &gt; 执行脚本，输出结果如下所示：&gt; a + b : 30&gt; a - b : -10&gt; a * b : 200&gt; b / a : 2&gt; b % a : 0&gt; a 不等于 b&gt; 注意： 乘号(*)前边必须加反斜杠()才能实现乘法运算 if…then…fi 是条件语句 在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 “*” 不需要转义符号 “\\” 关系运算符关系运算符只支持数字，不支持字符串，除非字符串的值是数字 下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。 -ne 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&gt; #!/bin/bash&gt; &gt; a=10&gt; b=20&gt; &gt; if [ $a -eq $b ]&gt; then&gt; echo \"$a -eq $b : a 等于 b\"&gt; else&gt; echo \"$a -eq $b: a 不等于 b\"&gt; fi&gt; if [ $a -ne $b ]&gt; then&gt; echo \"$a -ne $b: a 不等于 b\"&gt; else&gt; echo \"$a -ne $b : a 等于 b\"&gt; fi&gt; if [ $a -gt $b ]&gt; then&gt; echo \"$a -gt $b: a 大于 b\"&gt; else&gt; echo \"$a -gt $b: a 不大于 b\"&gt; fi&gt; if [ $a -lt $b ]&gt; then&gt; echo \"$a -lt $b: a 小于 b\"&gt; else&gt; echo \"$a -lt $b: a 不小于 b\"&gt; fi&gt; if [ $a -ge $b ]&gt; then&gt; echo \"$a -ge $b: a 大于或等于 b\"&gt; else&gt; echo \"$a -ge $b: a 小于 b\"&gt; fi&gt; if [ $a -le $b ]&gt; then&gt; echo \"$a -le $b: a 小于或等于 b\"&gt; else&gt; echo \"$a -le $b: a 大于 b\"&gt; fi&gt; &gt; 执行脚本，输出结果如下所示：&gt; 10 -eq 20: a 不等于 b&gt; 10 -ne 20: a 不等于 b&gt; 10 -gt 20: a 不大于 b&gt; 10 -lt 20: a 小于 b&gt; 10 -ge 20: a 小于 b&gt; 10 -le 20: a 小于或等于 b&gt; 布尔运算符下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 实例 1234567891011121314151617181920212223242526272829303132333435&gt; #!/bin/bash&gt; &gt; a=10&gt; b=20&gt; &gt; if [ $a != $b ]&gt; then&gt; echo \"$a != $b : a 不等于 b\"&gt; else&gt; echo \"$a == $b: a 等于 b\"&gt; fi&gt; if [ $a -lt 100 -a $b -gt 15 ]&gt; then&gt; echo \"$a 小于 100 且 $b 大于 15 : 返回 true\"&gt; else&gt; echo \"$a 小于 100 且 $b 大于 15 : 返回 false\"&gt; fi&gt; if [ $a -lt 100 -o $b -gt 100 ]&gt; then&gt; echo \"$a 小于 100 或 $b 大于 100 : 返回 true\"&gt; else&gt; echo \"$a 小于 100 或 $b 大于 100 : 返回 false\"&gt; fi&gt; if [ $a -lt 5 -o $b -gt 100 ]&gt; then&gt; echo \"$a 小于 5 或 $b 大于 100 : 返回 true\"&gt; else&gt; echo \"$a 小于 5 或 $b 大于 100 : 返回 false\"&gt; fi&gt; 执行脚本，输出结果如下所示：&gt; 10 != 20 : a 不等于 b&gt; 10 小于 100 且 20 大于 15 : 返回 true&gt; 10 小于 100 或 20 大于 100 : 返回 true&gt; 10 小于 5 或 20 大于 100 : 返回 false&gt; 逻辑运算符以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20: 运算符 说明 举例 &amp;&amp; 逻辑的 AND [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false \\ \\ 逻辑的 OR [[ $a -lt 100 \\ \\ $b -gt 100 ]] 返回 true 实例 12345678910111213141516171819202122&gt; #!/bin/bash&gt; &gt; a=10&gt; b=20&gt; &gt; if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]&gt; then&gt; echo \"返回 true\"&gt; else&gt; echo \"返回 false\"&gt; fi&gt; &gt; if [[ $a -lt 100 || $b -gt 100 ]]&gt; then&gt; echo \"返回 true\"&gt; else&gt; echo \"返回 false\"&gt; fi&gt; 执行脚本，输出结果如下所示：&gt; 返回 false&gt; 返回 true&gt; 字符串运算符下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”： 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -n “$a” ] 返回 true。 $ 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 实例 123456789101112131415161718192021222324252627282930313233343536373839404142&gt; #!/bin/bash&gt; &gt; a=\"abc\"&gt; b=\"efg\"&gt; &gt; if [ $a = $b ]&gt; then&gt; echo \"$a = $b : a 等于 b\"&gt; else&gt; echo \"$a = $b: a 不等于 b\"&gt; fi&gt; if [ $a != $b ]&gt; then&gt; echo \"$a != $b : a 不等于 b\"&gt; else&gt; echo \"$a != $b: a 等于 b\"&gt; fi&gt; if [ -z $a ]&gt; then&gt; echo \"-z $a : 字符串长度为 0\"&gt; else&gt; echo \"-z $a : 字符串长度不为 0\"&gt; fi&gt; if [ -n \"$a\" ]&gt; then&gt; echo \"-n $a : 字符串长度不为 0\"&gt; else&gt; echo \"-n $a : 字符串长度为 0\"&gt; fi&gt; if [ $a ]&gt; then&gt; echo \"$a : 字符串不为空\"&gt; else&gt; echo \"$a : 字符串为空\"&gt; fi&gt; 执行脚本，输出结果如下所示：&gt; abc = efg: a 不等于 b&gt; abc != efg : a 不等于 b&gt; -z abc : 字符串长度不为 0&gt; -n abc : 字符串长度不为 0&gt; abc : 字符串不为空&gt; 文件测试运算符文件测试运算符用于检测 Unix 文件的各种属性。 属性检测描述如下： 操作符 说明 举例 -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。 -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。 -p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。 -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 其他检查符： -S: 判断某文件是否 socket。 -L: 检测文件是否存在并且是一个符号链接。 实例 变量 file 表示文件 /test/test.sh，它的大小为 100 字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&gt; #!/bin/bash&gt; &gt; file=\"/test/test.sh\"&gt; if [ -r $file ]&gt; then&gt; echo \"文件可读\"&gt; else&gt; echo \"文件不可读\"&gt; fi&gt; if [ -w $file ]&gt; then&gt; echo \"文件可写\"&gt; else&gt; echo \"文件不可写\"&gt; fi&gt; if [ -x $file ]&gt; then&gt; echo \"文件可执行\"&gt; else&gt; echo \"文件不可执行\"&gt; fi&gt; if [ -f $file ]&gt; then&gt; echo \"文件为普通文件\"&gt; else&gt; echo \"文件为特殊文件\"&gt; fi&gt; if [ -d $file ]&gt; then&gt; echo \"文件是个目录\"&gt; else&gt; echo \"文件不是个目录\"&gt; fi&gt; if [ -s $file ]&gt; then&gt; echo \"文件不为空\"&gt; else&gt; echo \"文件为空\"&gt; fi&gt; if [ -e $file ]&gt; then&gt; echo \"文件存在\"&gt; else&gt; echo \"文件不存在\"&gt; fi&gt; 执行脚本，输出结果如下所示：&gt; 文件可读&gt; 文件可写&gt; 文件可执行&gt; 文件为普通文件&gt; 文件不是个目录&gt; 文件不为空&gt; 文件存在&gt;","tags":[{"name":"linux shell","slug":"linux-shell","permalink":"https://ivekes.github.io/tags/linux-shell/"}]},{"title":"进阶点滴","date":"2019-07-22T15:21:18.000Z","path":"2019/07/22/进阶点滴/","text":"java 线程池的实现原理 java 序列化的方式 字节流、字符流转换 http 和 https 的区别 常见的算法 springcloud 了解 数据的乐观锁、悲观锁 mysql 数据库相关1.存储引擎怎么查看，mysql支持的存储引擎？查看版本号 1select version(); 查看存储引擎 1show engines 2.乐观锁、悲观锁、共享锁、排它锁、行锁、表锁、死锁概念的理解?乐观锁和悲观锁 悲观锁 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它释放锁，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁 乐观锁 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号、时间戳等机制实现 总结 两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适 共享锁和排他锁 共享锁 对某一资源加共享锁，自身可以读该资源，其他人也可以读该资源（也可以再继续加共享锁，即 共享锁可多个共存），但无法修改。要想修改就必须等所有共享锁都释放完之后 排它锁/独占锁 对某一资源加排他锁，自身可以进行增删改查，其他人无法进行任何操作 注意 数据库的增删改操作默认都会加排他锁，而查询不会加任何锁 行锁、表锁和页面锁 行锁 开销大，加锁慢，会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高 表锁 开销小，加锁快，不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低 页面锁 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般 补充 MyISAM和MEMORY存储引擎采用的是表级锁，InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁 死锁 什么是死锁 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁 产生死锁的四个必要条件 互斥条件：一个资源每次只能被一个进程使用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 死锁的影响 当产生某表死锁的一开始,所有涉及这张表的操作都将受到阻塞。假设这张表在业务逻辑上是读写频繁的，那就会使很多操作在那里排队等待，而排队等待会占用数据库连接，当该达到该数据库连接数的最大承载数之后，就会使所有数据库操作均无法再继续下去，致使数据库各项指标异常，导致整个环境崩溃。在生产环境中出现这种问题，那是相当致命的，当发现数据库指标异常时因快速处理！ 发现死锁 第一种 123SHOW OPEN TABLES WHERE In_use &gt; 0;# 查询是否锁表show [full] processlist;#查询进程（如果您有SUP权限，您可以看到所有线程。否则，您只能看到您自己的线程）kill id;#杀死进程id（就是上面命令的id列） 第二种 123SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;#查看当前的事务SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;#查看当前锁定的事务SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;#查看当前等锁的事务 处理死锁 1kill 进程processID 降低死锁 按同一顺序访问对象。 避免事务中的用户交互。 保持事务简短并在一个批处理中。 使用低隔离级别。 使用绑定连接。 3.mysql 的执行计划","tags":[{"name":"java进阶","slug":"java进阶","permalink":"https://ivekes.github.io/tags/java进阶/"}]},{"title":"git点滴","date":"2019-07-20T04:48:15.000Z","path":"2019/07/20/git点滴/","text":"参考腾讯云社区 | 大侠咕咚 | 梦想_行人 | git练习动画 | 北山行者 github 上的 watch/star/fork watch—&gt;订阅 当选择 Watching，表示以后会关注这个项目的所有动态，这个项目以后只要发生变动，如被别人提交了 pull request、被别人发起了issue等等情况，都会在自己的个人通知中心，收到一条通知消息，如果设置了个人邮箱，那么邮箱也可能收到相应的邮件 star—&gt;关注/点赞 表示你喜欢这个项目 fork—&gt;收藏 当选择 fork，相当于自己有了一份原项目的拷贝，当然这个拷贝只是针对当时的项目文件，如果后续原项目文件发生改变，必须通过其他的方式去同步 github 上 fork 后代码与原项目保持一致项目地址 原项目地址： https://github.com/apache/dubbo.gitfork项目地址：https://github.com/ivekes/dubbo.git 步骤 检出自己在 github 上 fork 别人的分支到目录下 1$ git clone https://github.com/ivekes/dubbo.git 进到 _project 目录下，然后增加远程分支(fork的分支)，名为 update_stream（名字任意）到本地 1$ git remote add update_stream https://github.com/apache/dubbo.git 运行命令：git remote -v, 会发现多出来了一个 update_stream 的远程分支 12345$ git remote -vorigin https://github.com/ivekes/dubbo.git (fetch)origin https://github.com/ivekes/dubbo.git (push)update_stream https://github.com/apache/dubbo.git (fetch)update_stream https://github.com/apache/dubbo.git (push) 然后把远程原始分支 update_stream 的代码拉到本地 1$ git fetch update_stream 合并对方远程原始分支 update_stream 的代码 1$ git merge update_stream/master 最后把最新的代码推送到你的github上 1$ git push origin master 如果需要给 update_stream 发送 pull request 打开 https://github.com/ivekes/dubbo.git点击 pull request -&gt; 点击 new pull request -&gt; 输入title 和功能说明 -&gt; 点击 send pull request git 常用命令一、git 工作流程 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 工作区 程序员进行开发改动的地方，是你当前看到的，也是最新的。 平常我们开发就是拷贝远程仓库中的一个分支，基于该分支进行开发。在开发过程中就是对工作区的操作。 暂存区 .git目录下的index文件, 暂存区会记录git add添加文件的相关信息(文件名、大小、timestamp…)，不保存文件实体, 通过id指向每个文件实体。可以使用git status查看暂存区的状态。暂存区标记了你当前工作区中，哪些内容是被git管理的。 当你完成某个需求或功能后需要提交到远程仓库，那么第一步就是通过git add先提交到暂存区，被git管理。 本地仓库 保存了对象被提交过的各个版本，比起工作区和暂存区的内容，它要更旧一些。 git commit后同步index的目录树到本地仓库，方便从下一步通过git push同步本地仓库与远程仓库的同步。 远程仓库 远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。 小结 任何对象都是在工作区中诞生和被修改； 任何修改都是从进入index区才开始被版本控制； 只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹； 与协作者分享本地的修改，可以把它们push到远程仓库来共享。 下面这幅图更加直接阐述了四个区域之间的关系，可能有些命令不太清楚，没关系，下部分会详细介绍。 二、常用Git命令 命令 备注 git add . 添加当前目录的所有文件添加到暂存区，包括子目录 git add 添加指定目录到暂存区，包括子目录 git add 添加指定文件到暂存区 git commit -m 提交暂存区到本地仓库,message代表说明信息 git commit -m 提交暂存区的指定文件到本地仓库 git commit –amend -m 使用一次新的 commit ，替代上一次提交 git commit -a -m 提交工作区被tracked文件到本地仓库 git push 推送当前分支到远程仓库 git push –all 推送所有分支到远程仓库，remote 默认是 origin git push –force 强行推送当前分支到远程仓库，即使有冲突 git push 上传本地指定分支到远程仓库 git push -u origin 将本地的 branch 分支推送到 origin 主机，同时指定 origin 为默认主机 git push origin –delete 删除远程分支 git fetch 提取远程仓库更改到当前分支 git pull 提取远程仓库更改并合并到当前修改 git push origin –delete 删除远程分支 git branch 列出所有本地分支 git branch -r 列出所有远程分支 git branch -a 列出所有本地分支和远程分支 git branch 新建一个分支，但依然停留在当前分支 git branch -d 删除分支 git branch –track 新建一个分支，与指定的远程分支建立追踪关系 git checkout -b 新建一个分支，并切换到该分支 git checkout 切换到指定分支，并更新工作区 git reset —soft 只改变提交点，暂存区和工作目录的内容都不改变 git reset —mixed 改变提交点，同时改变暂存区的内容 git reset —hard 暂存区、工作区的内容都会被修改到与提交点完全一致的状态 git reset –hard HEAD 让工作区回到上次提交时的状态 git status 显示有变更的文件 git log 显示当前分支的版本历史 git diff 显示暂存区和工作区的差异 git diff HEAD 显示工作区与当前分支最新commit之间的差异 git cherry-pick 选择一个commit，合并进当前分支 三、相似命令区别rebase与merge的区别 现在我们有这样的两个分支,test和master，提交如下： 123 D---E test /A---B---C---F master 在master执行git merge test,然后会得到如下结果： 123 D--------E / \\A---B---C---F----G test, master 在master执行git rebase test，然后得到如下结果： 1A---B---D---E---C'---F' test, master 可以看到，merge操作会生成一个新的节点，之前的提交分开显示。而rebase操作不会生成新的节点，是将两个分支融合成一个线性的提交。 如果你想要一个干净的，没有merge commit的线性历史树，那么你应该选择git rebase 如果你想保留完整的历史记录，并且想要避免重写commit history的风险，你应该选择使用git merge revert与reset的区别 git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。 在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，减少冲突。但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入，产生很多冲突。关于这一点，不太理解的可以看这篇文章。 git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容 以上命令的详细解释，请移步 腾讯云社区","tags":[{"name":"git github","slug":"git-github","permalink":"https://ivekes.github.io/tags/git-github/"}]},{"title":"java基础","date":"2019-06-07T14:45:48.000Z","path":"2019/06/07/java基础/","text":"位运算2 、3 、4 和 -4 的二进制如下，本例在此基础上做演示 2 =======&gt;0010 3 =======&gt;0011 4=======&gt;0100 -4=======&gt;1111 1111 1111 1111 1111 1111 1111 1100 ^(亦或运算) ，针对二进制，相同的为0，不同的为1 1234public void yihuo()&#123; System.out.println(\"2^3运算的结果是 :\"+(2^3)); //2^3运算的结果是 :1&#125; &amp;（与运算） 针对二进制，只要有一个为0，就为0 1234public void yu()&#123; System.out.println(\"2&amp;3运算的结果是 :\"+(2&amp;3)); //2&amp;3运算的结果是 :2&#125; &lt;&lt;(向左位移) 针对二进制，转换成二进制后向左移动 n 位，后面用 0 补齐 1234public void zuoyi()&#123; System.out.println(\"2&lt;&lt;3运算的结果是 :\"+(2&lt;&lt;3)); //2&lt;&lt;3运算的结果是 :16&#125; &gt;&gt;(向右位移) 针对二进制，转换成二进制后向右移动 n 位 1234public void youyi()&#123; System.out.println(\"2&gt;&gt;3运算的结果是 :\"+(2&gt;&gt;3)); //2&gt;&gt;3运算的结果是 :0&#125; &gt;&gt;&gt;(无符号右移) 无符号右移，忽略符号位，空位都以0补齐 12345678910public void wufuhaoyouyi()&#123; System.out.println(\"4&gt;&gt;2运算的结果是 :\"+((4)&gt;&gt;2)); System.out.println(\"-4&gt;&gt;2运算的结果是 :\"+((-4)&gt;&gt;2)); System.out.println(\"4&gt;&gt;&gt;2运算的结果是 :\"+((4)&gt;&gt;&gt;2)); System.out.println(\"-4&gt;&gt;&gt;2运算的结果是 :\"+((-4)&gt;&gt;&gt;2)); //4&gt;&gt;2运算的结果是 :1 //-4&gt;&gt;2运算的结果是 :-1 //4&gt;&gt;&gt;2运算的结果是 :1 //-4&gt;&gt;&gt;2运算的结果是 :1073741823&#125; 十进制负数转二进制规则 首先将负数转换为对应的原码 12-4 的原码为(也就是+4转换成二进制后的字符串)：0000 0000 0000 0000 0000 0000 0000 0100 再将原码的每一位做取反操作得到反码 12取反操作：0变为1 、 1变为0；取反后的结果即为：1111 1111 1111 1111 1111 1111 1111 1011 将反码+1得到补码 11111 1111 1111 1111 1111 1111 1111 1100","tags":[{"name":"java，位运算","slug":"java，位运算","permalink":"https://ivekes.github.io/tags/java，位运算/"}]},{"title":"快捷键","date":"2019-06-05T16:16:14.000Z","path":"2019/06/06/快捷键/","text":"idea 常用命令 命令 描述 ctrl + alt + u 打开类图 alt + insert 重写父类方法 ctrl + alt + b 查看子类 ctrl + alt + z git revert ctrl + e 最近的文件 ctrl + shift + e 最近更改的文件 shift + click 关闭文件 ctrl + n 快速打开类 ctrl + shift + n 快速打开文件 ctrl + alt + t 把代码包在一个块内，例如：try/catch ctrl + enter 导入包，自动修正 ctrl + alt + l 格式化代码 ctrl + alt + i 选中的代码自动缩进编排 ctrl + alt + o 优化导入的类和包 ctrl + r 替换文本 ctrl + f 查找文本 alt + shift + c 最近的更改 alt + shift + up/down 上/下移一行 shift + f6 重构或重命名 ctrl + x 删除行 ctrl + d 复制行 ctrl + / 或 ctrl + shift + / 注释（//或者/**/） ctrl + h 显示类结构图（类的继承层次） ctrl + q 显示注释文档 alt + f1 查找代码所在位置 alt + 1 快速打开或隐藏工程面板 ctrl + alt + left/right 返回至上次浏览的位置 alt + left/right 切换代码视图 alt + up/down 在方法间快速移动定位 ctrl + shift + up/down 向上/下移动语句 f2 或 shift + f2 高亮错误或警告快速定位 ctrl + shift + f7 高亮显示所有该文本，按 Esc 高亮消失 alt + f3 逐个往下查找相同文本，并高亮显示 ctrl + shift + backspace 跳转到上次编辑的地方 ctrl + o 重写方法 alt + f7 查找整个工程中使用地某一个类、方法或者变量的位置 ctrl + shift + u 大小写转化 shift + enter 向下插入新行 ctrl + shift + f 全局查找 ctrl + f 查找 ctrl + u 转到父类 ctrl + g 定位行 ctrl + enter 上插一行 ctrl + backspace 按单词删除 ctrl + ”+/-” 当前方法展开、折叠 ctrl + shift + ”+/-” 全部展开、折叠 f8 步过 alt + f9 运行至光标处 ctrl + alt + f9 强制运行至光标处 alt + 6 TODO ctrl + shift + c 复制绝对路径 shift + f6 重命名 idea 常用配置 配置 描述 notifications 配置通知 plugins 插件管理 keymap 快捷键管理 appearance 设置IntelliJ IDEA显示内存，主题风格等 idea 常用配置_终端 terminal 为 cmder 增加系统变量 变量名为：CMDER_HOME 变量值为：D:\\tools\\cmder (主机上 Cmder 安装主目录) 打开设置（快捷键：Ctrl + Alt + S），进入 Plugins,搜索栏搜索 Terminal，查看 Terminal 插件是否打勾选中，如果没有，请打勾 进入设置（快捷键：Ctrl + Alt + S），进入 Tools 字段，再进入 Terminal 字段，在 Shell path 那一栏中，输入你主机 cmder 的安装位置 1&quot;cmd.exe&quot; /k &quot;&quot;%CMDER_HOME%\\vendor\\init.bat&quot;&quot; 重新启动 Idea IDE，然后打开 Terminal 查看是否配置正确 如果没有，请检查路径中，是否正确加了英文双引号，路径是否正确。有的老版本，cmd.exe 两边是不需要加双引号的，但是新版本的策略中，都要求加双引号了 idea 常用配置_项目隐藏.idea文件夹 打开设置：Ctrl + Alt + s 或者菜单File &gt; Settings… 在打开的窗口中。选择Editor &gt; File Types， 在右侧下方Ingore files and folders输入 .idea idea 常用配置_类注释模版 首先点击右上角的file 点击进入settings 选择 Editor—&gt; File and Code Templates—&gt;includes—&gt;FileHeader 在里面定义你自己想要的签名 1234/** * @author ivekes * @date $&#123;YEAR&#125;/$&#123;MONTH&#125;/$&#123;DAY&#125; */ idea 常用配置_方法注释模版 选中自己的模版组，在模板组下新建模板 如下图给模板设置信息 1-设置模板名称，建议不要换，就是 * 号 2-模板描述，可以没有 3-模板，注意开头是没有 /* 的 4-添加模板生成的地方，点开选择java或者全部都可以 5-设置模板快捷键，我设置为回车 6-编辑模板中的参数 7-点apply完成 8-用法：跟原来的一样： /* + 回车 即可，这就是取名为 的好处 idea .ignore 插件安装配置和使用 安装.ignore插件 file–&gt;setting–&gt;plugins–&gt;搜索.ignore–&gt;install 自定义.ignore模板 file–&gt;setting–&gt;version control–&gt;ignore files support 使用 右键工程，按如下操作 在user templates中选择你自定义的模板，然后右下角generate即可生成.gitignore文件 idea 常用插件 名称 描述 bashsupport 插件 shell 支持 alibaba java coding guidelines 阿里巴巴语法提示向导 a8translate 翻译插件 gsonformat 快速将JSON字符串转换为内部类实体类 lombok 自动生成getter,setter,log,构造方法等 .ignore git提交时过滤掉不需要提交的文件 camelcase 将不是驼峰格式的名称 free mybatis plugin 可以在mapper接口中和mapper的xml文件中来回跳转 generateallsetter 一键调用一个对象的所有set方法并且赋予默认值 codeglance 在编辑区的右侧显示的代码地图 rainbow brackets 彩虹颜色的括号 mybatiscodehelperpro 根据 java 对象一键生成 Dao 接口，Service，Xml git 常用命令git init 在本地新建一个repo,进入一个项目目录,执行git init,会初始化一个repo,并在当前文件夹下创建一个.git文件夹. git clone 获取一个url对应的远程Git repo, 创建一个local copy. 一般的格式是git clone [url]. clone下来的repo会以url最后一个斜线后面的名称命名,创建一个文件夹,如果想要指定特定的名称,可以git clone [url] newname指定. git status 查询repo的状态. git status -s: -s表示short, -s的输出标记会有两列,第一列是对staging区域而言,第二列是对working目录而言. git log show commit history of a branch. git log –oneline –number: 每条log只显示一行,显示number条. git log –oneline –graph:可以图形化地表示出分支合并历史. git log branchname可以显示特定分支的log. git log –oneline branch1 ^branch2,可以查看在分支1,却不在分支2中的提交.^表示排除这个分支(Window下可能要给^branch2加上引号). git log –decorate会显示出tag信息. git log –author=[author name] 可以指定作者的提交历史. git log –since –before –until –after 根据提交时间筛选log. –no-merges可以将merge的commits排除在外. git log –grep 根据commit信息过滤log: git log –grep=keywords 默认情况下, git log –grep –author是OR的关系,即满足一条即被返回,如果你想让它们是AND的关系,可以加上–all-match的option. git log -S: filter by introduced diff. 比如: git log -SmethodName (注意S和后面的词之间没有等号分隔). git log -p: show patch introduced at each commit. 每一个提交都是一个快照(snapshot),Git会把每次提交的diff计算出来,作为一个patch显示给你看. 另一种方法是git show [SHA]. git log –stat: show diffstat of changes introduced at each commit. 同样是用来看改动的相对信息的,–stat比-p的输出更简单一些. git add 在提交之前,Git有一个暂存区(staging area),可以放入新添加的文件或者加入新的改动. commit时提交的改动是上一次加入到staging area中的改动,而不是我们disk上的改动. git add . 会递归地添加当前工作目录中的所有文件. git diff 不加参数的git diff: show diff of unstaged changes. 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容. ​ 若要看已经暂存起来的文件和上次提交时的快照之间的差异,可以用:​ git diff –cached 命令.​ show diff of staged changes.​ (Git 1.6.1 及更高版本还允许使用 git diff –staged，效果是相同的). ​ git diff HEAD​ show diff of all staged or unstated changes.​ 也即比较woking directory和上次提交之间所有的改动. ​ 如果想看自从某个版本之后都改动了什么,可以用:​ git diff [version tag]​ 跟log命令一样,diff也可以加上–stat参数来简化输出. ​ git diff [branchA] [branchB]可以用来比较两个分支.​ 它实际上会返回一个由A到B的patch,不是我们想要的结果.​ 一般我们想要的结果是两个分支分开以后各自的改动都是什么,是由命令:​ git diff [branchA]…[branchB]给出的.​ 实际上它是:git diff $(git merge-base [branchA] [branchB]) [branchB]的结果. git commit 提交已经被add进来的改动. git commit -m “the commit message” git commit -a 会先把所有已经track的文件的改动add进来,然后提交(有点像svn的一次提交,不用先暂存). 对于没有track的文件,还是需要git add一下. git commit –amend 增补提交. 会使用与当前提交节点相同的父节点进行一次新的提交,旧的提交将会被取消. git reset undo changes and commits. 这里的HEAD关键字指的是当前分支最末梢最新的一个提交.也就是版本库中该分支上的最新版本. git reset HEAD: unstage files from index and reset pointer to HEAD 这个命令用来把不小心add进去的文件从staged状态取出来,可以单独针对某一个文件操作: git reset HEAD - - filename, 这个- - 也可以不加. git reset –soft move HEAD to specific commit reference, index and staging are untouched. git reset –hard unstage files AND undo any changes in the working directory since last commit. 使用git reset —hard HEAD进行reset,即上次提交之后,所有staged的改动和工作目录的改动都会消失,还原到上次提交的状态. 这里的HEAD可以被写成任何一次提交的SHA-1. 不带soft和hard参数的git reset,实际上带的是默认参数mixed. ​ 总结:​ git reset –mixed id,是将git的HEAD变了(也就是提交记录变了),但文件并没有改变，(也就是working tree并没有改变). 取消了commit和add的内容.​ git reset –soft id. 实际上，是git reset –mixed id 后,又做了一次git add.即取消了commit的内容.​ git reset –hard id.是将git的HEAD变了,文件也变了.​ 按改动范围排序如下:​ soft (commit) &lt; mixed (commit + add) &lt; hard (commit + add + local working) git revert 反转撤销提交.只要把出错的提交(commit)的名字(reference)作为参数传给命令就可以了. git revert HEAD: 撤销最近的一个提交. git revert会创建一个反向的新提交,可以通过参数-n来告诉Git先不要提交. git rm git rm file: 从staging区移除文件,同时也移除出工作目录. git rm –cached: 从staging区移除文件,但留在工作目录中. git rm –cached从功能上等同于git reset HEAD,清除了缓存区,但不动工作目录树. git clean git clean是从工作目录中移除没有track的文件. 通常的参数是git clean -df: -d表示同时移除目录,-f表示force,因为在git的配置文件中, clean.requireForce=true,如果不加-f,clean将会拒绝执行. git mv git rm - - cached orig; mv orig new; git add new git stash 把当前的改动压入一个栈. git stash将会把当前目录和index中的所有改动(但不包括未track的文件)压入一个栈,然后留给你一个clean的工作状态,即处于上一次最新提交处. git stash list会显示这个栈的list. git stash apply:取出stash中的上一个项目(stash@{0}),并且应用于当前的工作目录. 也可以指定别的项目,比如git stash apply stash@{1}. 如果你在应用stash中项目的同时想要删除它,可以用git stash pop ​ 删除stash中的项目:​ git stash drop: 删除上一个,也可指定参数删除指定的一个项目.​ git stash clear: 删除所有项目. git branch git branch可以用来列出分支,创建分支和删除分支. git branch -v可以看见每一个分支的最后一次提交. git branch: 列出本地所有分支,当前分支会被星号标示出. git branch (branchname): 创建一个新的分支(当你用这种方式创建分支的时候,分支是基于你的上一次提交建立的). git branch -d (branchname): 删除一个分支. 删除remote的分支: git push (remote-name) :(branch-name): delete a remote branch. 这个是因为完整的命令形式是: git push remote-name local-branch:remote-branch 而这里local-branch的部分为空,就意味着删除了remote-branch git checkout git checkout (branchname) 切换到一个分支. git checkout -b (branchname): 创建并切换到新的分支. 这个命令是将git branch newbranch和git checkout newbranch合在一起的结果. checkout还有另一个作用:替换本地改动: git checkout – 此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件.已添加到暂存区的改动以及新文件都不会受到影响. 注意:git checkout filename会删除该文件中所有没有暂存和提交的改动,这个操作是不可逆的. git merge 把一个分支merge进当前的分支. git merge [alias]/[branch] 把远程分支merge到当前分支. ​ 如果出现冲突,需要手动修改,可以用git mergetool.​ 解决冲突的时候可以用到git diff,解决完之后用git add添加,即表示冲突已经被resolved. git tag tag a point in history as import. 会在一个提交上建立永久性的书签,通常是发布一个release版本或者ship了什么东西之后加tag. 比如: git tag v1.0 git tag -a v1.0, -a参数会允许你添加一些信息,即make an annotated tag. 当你运行git tag -a命令的时候,Git会打开一个编辑器让你输入tag信息. 我们可以利用commit SHA来给一个过去的提交打tag: git tag -a v0.9 XXXX ​ push的时候是不包含tag的,如果想包含,可以在push时加上–tags参数.​ fetch的时候,branch HEAD可以reach的tags是自动被fetch下来的, tags that aren’t reachable from branch heads will be skipped.如果想确保所有的tags都被包含进来,需要加上–tags选项. git remote list, add and delete remote repository aliases. 因为不需要每次都用完整的url,所以Git为每一个remote repo的url都建立一个别名,然后用git remote来管理这个list. git remote: 列出remote aliases. 如果你clone一个project,Git会自动将原来的url添加进来,别名就叫做:origin. git remote -v:可以看见每一个别名对应的实际url. git remote add [alias] [url]: 添加一个新的remote repo. git remote rm [alias]: 删除一个存在的remote alias. git remote rename [old-alias] [new-alias]: 重命名. git remote set-url [alias] [url]:更新url. 可以加上—push和fetch参数,为同一个别名set不同的存取地址. git fetch download new branches and data from a remote repository. 可以git fetch [alias]取某一个远程repo,也可以git fetch –all取到全部repo fetch将会取到所有你本地没有的数据,所有取下来的分支可以被叫做remote branches,它们和本地分支一样(可以看diff,log等,也可以merge到其他分支),但是Git不允许你checkout到它们. git pull fetch from a remote repo and try to merge into the current branch. pull == fetch + merge FETCH_HEAD git pull会首先执行git fetch,然后执行git merge,把取来的分支的head merge到当前分支.这个merge操作会产生一个新的commit. 如果使用–rebase参数,它会执行git rebase来取代原来的git merge. git rebase –rebase不会产生合并的提交,它会将本地的所有提交临时保存为补丁(patch),放在”.git/rebase”目录中,然后将当前分支更新到最新的分支尖端,最后把保存的补丁应用到分支上. rebase的过程中,也许会出现冲突,Git会停止rebase并让你解决冲突,在解决完冲突之后,用git add去更新这些内容,然后无需执行commit,只需要: git rebase –continue就会继续打余下的补丁. git rebase –abort将会终止rebase,当前分支将会回到rebase之前的状态. git push push your new branches and data to a remote repository. git push [alias] [branch] 将会把当前分支merge到alias上的[branch]分支.如果分支已经存在,将会更新,如果不存在,将会添加这个分支. 如果有多个人向同一个remote repo push代码, Git会首先在你试图push的分支上运行git log,检查它的历史中是否能看到server上的branch现在的tip,如果本地历史中不能看到server的tip,说明本地的代码不是最新的,Git会拒绝你的push,让你先fetch,merge,之后再push,这样就保证了所有人的改动都会被考虑进来. git reflog git reflog是对reflog进行管理的命令,reflog是git用来记录引用变化的一种机制,比如记录分支的变化或者是HEAD引用的变化. 当git reflog不指定引用的时候,默认列出HEAD的reflog. HEAD@{0}代表HEAD当前的值,HEAD@{3}代表HEAD在3次变化之前的值. git会将变化记录到HEAD对应的reflog文件中,其路径为.git/logs/HEAD, 分支的reflog文件都放在.git/logs/refs目录下的子目录中. 特殊符号: ^代表父提交,当一个提交有多个父提交时,可以通过在^后面跟上一个数字,表示第几个父提交: ^相当于^1. ~相当于连续的个^. linux 常用命令 命令 描述 netstat -tunlp丨grep 8000 查询端口 ip addr 查看ip systemctl start xxxx 启动某服务 systemctl enable xxxx 设置某服务为开机启动 systemctl stop firewalld.service 关闭防火墙 systemctl status firewalld.service 查看防火墙状态 systemctl disable firewalld.service 禁止防火墙自动启动 docker 常用命令 命令 描述 参数 实例 docker info 显示 Docker 系统信息，包括镜像和容器数 无 docker images 列出本地镜像 docker search xxx 从Docker Hub查找镜像 docker rm 删除容器 docker rmi 删除镜像 docker pull [OPTIONS] NAME[:TAG丨@DIGEST] 从镜像仓库中拉取或者更新指定镜像 docker run [OPTIONS] IMAGE [COMMAND] [ARG…] 创建一个新的容器并运行一个命令 -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；-d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -p: 端口映射，格式为：主机(宿主)端口:容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； –name=”nginx-lb”: 为容器指定一个名称； –dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； –dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h “mars”: 指定容器的hostname； -e username=”ritchie”: 设置环境变量； –env-file=[]: 从指定文件读入环境变量； –cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行； -m :设置容器使用内存最大值； –net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； –link=[]: 添加链接到另一个容器； –expose=[]: 开放一个端口或一组端口； docker run –name mynginx -d nginx:latest使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx docker ps [OPTIONS] 列出容器 -a :显示所有的容器，包括未运行的。-f :根据条件过滤显示的内容。–format :指定返回值的模板文件。-l :显示最近创建的容器。-n :列出最近创建的n个容器。–no-trunc :不截断输出。-q :静默模式，只显示容器编号。-s :显示总的文件大小。 docker ps -n 5列出最近创建的5个容器信息 hexo 常用命令 命令 描述 hexo d丨hexo deploy 重新部署到服务器 hexo g 丨 hexo generate 生成静态页面 hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo new &quot;postName&quot; 新建一个名称为 postName 的文章","tags":[{"name":"idea,linux,docker,hexo","slug":"idea-linux-docker-hexo","permalink":"https://ivekes.github.io/tags/idea-linux-docker-hexo/"}]},{"title":"rocketmq点滴","date":"2019-06-01T06:14:02.000Z","path":"2019/06/01/rocketmq点滴/","text":"环境 centos7 内存2g jdk1.8 rocketmq4.4.0 说明：参考资料 rocketmq官网 吾同树 下载 &amp; 安装 下载 源码下载 zip包下载 rocketmq-externals下载 解压 1234$ unzip rocketmq-all-4.4.0-source-release.zip$ cd rocketmq-all-4.4.0/$ mvn -Prelease-all -DskipTests clean install -U$ cd distribution/target/apache-rocketmq 启动 nameserver 123$ nohup sh bin/mqnamesrv &amp;$ tail -f ~/logs/rocketmqlogs/namesrv.logThe Name Server boot success... 启动 broker 123$ nohup sh bin/mqbroker -n localhost:9876 &amp;$ tail -f ~/logs/rocketmqlogs/broker.log The broker[%s, 172.30.30.233:10911] boot success... 发送 &amp; 接收消息 123456$ export NAMESRV_ADDR=localhost:9876$ sh bin/tools.sh org.apache.rocketmq.example.quickstart.ProducerSendResult [sendStatus=SEND_OK, msgId= ...$ sh bin/tools.sh org.apache.rocketmq.example.quickstart.ConsumerConsumeMessageThread_%d Receive New Messages: [MessageExt... 安装 rocketmq-console rocketmq-externals 中有很多项目，我们这里只需要 rocketmq-console， 它是依赖于springboot-1.4.3.RELEASE 的 springboot 项目，导入 idea,修改配置文件 application.properties，把服务器地址修改成自己的，然后直接运行app.java 就可以了 1rocketmq.config.namesrvAddr=mynode7:9876 也可将项目打成 jar 包，并运行 jar 文件 1234$ mvn clean package -Dmaven.test.skip=true$ java -jar target/rocketmq-console-ng-1.0.1.jar# 如果配置文件没有填写Name Server$ java -jar target/rocketmq-console-ng-1.0.1.jar --rocketmq.config.namesrvAddr='mynode7:9876' 启动成功后，输入 http://localhost:8080/ ,即可进入管理后台操作 停止服务 1234567$ sh bin/mqshutdown brokerThe mqbroker(36695) is running...Send shutdown request to mqbroker(36695) OK$ sh bin/mqshutdown namesrvThe mqnamesrv(36664) is running...Send shutdown request to mqnamesrv(36664) OK 异常 &amp; 解决方案启动的过程中有可能遇到 broker 启动不起来的情况，修改$ROCKETMQ_HOME/bin/runbroker.sh 123$ vim bin/runbroker.shJAVA_OPT=\"$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m -Xmn512m\"JAVA_OPT=\"$&#123;JAVA_OPT&#125; -XX:MaxDirectMemorySize=1g\" 命令行管理工具1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$ sh bin/mqadminThe most commonly used mqadmin commands are: updateTopic Update or create topic deleteTopic Delete topic from broker and NameServer. updateSubGroup Update or create subscription group deleteSubGroup Delete subscription group from broker. updateBrokerConfig Update broker's config updateTopicPerm Update topic perm topicRoute Examine topic route info topicStatus Examine topic Status info topicClusterList get cluster info for topic brokerStatus Fetch broker runtime status data queryMsgById Query Message by Id queryMsgByKey Query Message by Key queryMsgByUniqueKey Query Message by Unique key queryMsgByOffset Query Message by offset printMsg Print Message Detail printMsgByQueue Print Message Detail sendMsgStatus send msg to broker. brokerConsumeStats Fetch broker consume stats data producerConnection Query producer's socket connection and client version consumerConnection Query consumer's socket connection, client version and subscription consumerProgress Query consumers's progress, speed consumerStatus Query consumer's internal data structure cloneGroupOffset clone offset from other group. clusterList List all of clusters topicList Fetch all topic list from name server updateKvConfig Create or update KV config. deleteKvConfig Delete KV config. wipeWritePerm Wipe write perm of broker in all name server resetOffsetByTime Reset consumer offset by timestamp(without client restart). updateOrderConf Create or update or delete order conf cleanExpiredCQ Clean expired ConsumeQueue on broker. cleanUnusedTopic Clean unused topic on broker. startMonitoring Start Monitoring statsAll Topic and Consumer tps stats allocateMQ Allocate MQ checkMsgSendRT check message send response time clusterRT List All clusters Message Send RT getNamesrvConfig Get configs of name server. updateNamesrvConfig Update configs of name server. getBrokerConfig Get broker config by cluster or special broker! queryCq Query cq command. sendMessage Send a message consumeMessage Consume messageSee 'mqadmin help &lt;command&gt;' for more information on a specific command","tags":[{"name":"rocketmq","slug":"rocketmq","permalink":"https://ivekes.github.io/tags/rocketmq/"}]},{"title":"centos7新机及克隆","date":"2019-05-25T05:25:06.000Z","path":"2019/05/25/centos7新机及克隆/","text":"预安装工具1$ yum install -y wget vim vim 设置,添加以下配置 1$ vi /etc/vimrc set nu #设置行号set autoindent #自动缩进set ts=4 #这个是设置tap的大小为4个空格set mouse=a #所有的模式使用鼠标 修改为阿里镜像库 备份原来的 yum 源 1$ cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak 设置 aliyun 的 yum 源 1$ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 添加 epel 源 1$ wget -P /etc/yum.repos.d/ http://mirrors.aliyun.com/repo/epel-7.repo 清理缓存并生成新的缓存 12$ yum clean all$ yum makecache 克隆后的设置设置主机名 1$ hostnamectl set-hostname mynode1 网卡配置 12# 文件中HWADDR、UUID删除，更改 IPADDR$ vim /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=eth0TYPE=EthernetONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.135.131NETMASK=255.255.255.0GATEWAY=192.168.135.2DNS1=192.168.135.2 其他配置 12rm -f /etc/udev/rules.d/70-persistent-net.rules 文件删除（centos7克隆后如没有该文件，则不做此操作）echo '192.168.135.131 mynode1' &gt;&gt; /etc/hosts 安装其他工具yum install -y xz lrzsz man man-pages ntp psmisc lsof 免密登陆 修改每台机器的主机名后，更改每台机器的hosts文件，如下 192.168.135.136 mynode6192.168.135.137 mynode7192.168.135.138 mynode8 在 mynode6 上执行如下命令： 123456789# 生成本机公钥，过程中不断回车即可，该公钥会被放置在/root/.ssh目录下$ ssh-keygen -t rsa $ cd /root/.ssh# 将公钥复制到authorized_keys文件中$ cat id_rsa.pub &gt;&gt; authorized_keys# 此时本机使用ssh mynode6 连接就不需要输密码了,继续配置其他免密登陆，在 mynode6 执行如下命令$ ssh-copy-id -i mynode7$ ssh-copy-id -i mynode8# 分别在 mynode7 mynode8 中重复执行如上命令即可","tags":[{"name":"centos7","slug":"centos7","permalink":"https://ivekes.github.io/tags/centos7/"}]},{"title":"zookeper点滴","date":"2019-05-25T05:23:10.000Z","path":"2019/05/25/zookeper点滴/","text":"环境 内存2g jdk1.8 zookeeper3.5.5 centos7 3个节点 mynode6,mynode7,mynode8 说明：参考资料 zookeeper官网 努力改个网名 简单理解Zookeeper的Leader选举 下载 &amp; 单机安装 下载 tar包下载 解压 1$ tar zxvf apache-zookeeper-3.5.5-bin.tar.gz -C zookeeper 配置 在 zk 目录下创建目录 data 和 logs 两个目录存储数据和日志 1$ mkdir -p /tools/zookeeper/&#123;data,logs&#125; 在 conf 目录下新建 zoo.cfg 文件，写入以下内容保存 1234tickTime=2000dataDir=/tools/zookeeper/datadataLogDir=/tools/zookeeper/logsclientPort=2181 启动 &amp; 停止 1234$ ./zkServer.sh start$ ./zkServer.sh stop$ ./zkServer.sh restart$ ./zkServer.sh status 集群模式 关闭防火墙和selinux 123456# 关闭防火墙systemctl stop firewalld.service# 禁止防火墙自动启动systemctl disable firewalld.service# 关闭selinux : setenforce 0# 禁止selinux启动：vim /etc/selinux/config SELINUX=disabled 将单机模式下配置好的 zookeeper 分发到其他节点 12$ scp -r zookeeper mynode7:`pwd`$ scp -r zookeeper mynode8:`pwd` conf/zoo.cfg文件修改 123456789tickTime=2000dataDir=/tools/zookeeper/datadataLogDir=/tools/zookeeper/logsclientPort=2181initLimit=5syncLimit=2server.1=mynode6:2888:3888server.2=mynode7:2888:3888server.3=mynode8:2888:3888 data/myid文件修改 mynode6 1$ echo '1' &gt; /tools/zookeeper/data/myid mynode7 1$ echo '2' &gt; /tools/zookeeper/data/myid mynode8 1$ echo '3' &gt; /tools/zookeeper/data/myid 添加环境变量 12echo -e 'export ZOOKEEPER_HOME=/tools/zookeeper \\n export PATH=$ZOOKEEPER_HOME/bin:$PATH' &gt;&gt;/etc/profilesource /etc/profile 启动 设计思想集群角色 leader 是整个 zookeeper 服务的核心，主要职责有如下两项： 集群内部各服务器的调度者 事务请求的唯一调度和处理者，保证集群事务处理的顺序性 follower 主要职责如下： 参与 leader 的选举的投票 处理客户端非事务请求，转发事务请求给 leader 服务器 参与事务请求的 proposal 的投票（需要半数以上服务器通过才能通知 leader commit 数据，leader 发起提案，要求 follow 投票） observer 是 zk 3.3 开始引入的一个全新的服务器角色，充当观察者的角色 观察并同步 zk 集群最新状态变化到 observer 服务器上 与 follow 的区别，observer 不参与任何形式的投票，包括事务 proposal 的投票和 leader 选举的投票 looking 寻找 leader 状态，处于该状态需要进入选举流程 节点状态 looking 当前 server 不知道 leader 是谁，正在搜寻 leading 当前 server 被选为 leader following leader 已经选举出来，当前server与 leader 同步 leader 选举初始期间 每个 server 发出一个将自己作为 leader 的投票,该次投票会包含所推举的服务器 myid 和 zxid ，发送给集群的其他机器 接收来自各个服务器的投票，判断该投票的有效性，如检查是否来自本轮投票、是否来自 looking 状态的服务器 处理投票，对每一个投票，server 都需要将其他节点的投票和自己的投票进行比较，规则是先比较 zxid 谁大确认谁做 leader，如果相同比较 myid，谁大确认谁做 leader,确认后发送投票给确认的 leader 统计投票，每次投票后，服务器会统计投票信息，判断是否已经有过半的机器接收到相同的投票信息 改变服务器状态，一旦确定 leader，每个服务器会更新自己的状态，leader 变更为 leading， follower 变更为 following 运行期间 变更状态，leader 挂掉后，余下的非 observer 服务器会将自己的服务器状态变更为 looking，然后开始进入 leader 选举过程 每个 server 发出一个投票给集群中所有机器 接收来自各个服务器的投票，与启动相同 处理投票，与启动相同 统计投票，与启动相同 改变服务器状态，与启动相同 数据同步和数据一致性为了简化集群数据同步的复杂性，将客户端请求分为事务性数据请求和非事务性数据请求，leader 节点可以处理事务和非事务型数据，follower 节点只能处理非事务性数据。leader 节点和其他节点为保持数据一致性，需要用到分布式事务，分布式事务有 2pc 和 3pc 协议 阶段一：提交事务请求（投票） 事务询问 协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应 执行事务 各个参与者节点执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中，尽量把提交过程中所有消耗时间的操作和准备都提前完成确保后面 100%成功提交事务 各个参与者向协调者反馈事务询问的响应 如果各个参与者成功执行了事务操作，那么就反馈给参与者 yes 的响应，表示事务可以执行；如果参与者没有成功执行事务，就反馈给协调者 no 的响应，表示事务不可以执行，上面这个阶段有点类似协调者组织各个参与者对一次事务操作的投票表态过程，因此 2pc 协议的第一个阶段称为“投票阶段”，即各参与者投票表名是否需要继续执行接下去的事务提交操作 执行事务提交 在这个阶段，协调者会根据各参与者的反馈情况来决定最终是否可以进行事务提交操作，正常情况下包含两种可能:执行事务、中断事务 节点特性 持久化节点 顺序节点create -s [/key] value 临时节点`create -e /key value ttl 和 容器节点 临时节点不能存在子节点 创建节点时，必须要带上全路径 同一级别的节点不能存在重复 节点操作 创建节点 能够创建顺序节点create -s [/key] value 能够创建临时节点create -e /key value 删除节点 节点只能一层一层的删除 可以通过 deleteall key 实现递归删除 修改节点 修改命令set key value 查看节点 watcher 机制 get -w key，只会监听到一次","tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"https://ivekes.github.io/tags/zookeeper/"}]},{"title":"springcloud点滴","date":"2019-05-25T05:19:47.000Z","path":"2019/05/25/springcloud点滴/","text":"","tags":[{"name":"springcloud","slug":"springcloud","permalink":"https://ivekes.github.io/tags/springcloud/"}]}]